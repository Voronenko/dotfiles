#!/usr/bin/env bash
set -euo pipefail

# Function to list SSH keys in ~/.ssh directory
list_ssh_keys() {
  find -L "${HOME}/.ssh" -type f \( -name "*.gpg" -o -name "*.pem" -o -not -name "*.*" \) -not \( -name "authorized_keys" -o -name "known_hosts" -o -name "config" -o -name "environment" \) -printf "%p\n" | while read -r file; do
    if [[ "$file" == *.gpg ]]; then
      # Encrypted GPG file - show in orange without .gpg extension
      echo -e "\033[38;5;208m${file%.gpg}\033[0m"
    else
      # Regular key file - show in green
      echo -e "\033[38;5;76m$file\033[0m"
    fi
  done
}

# Check if 'ssh-add' is available
if ! command -v ssh-add >/dev/null 2>&1; then
  echo "Error: 'ssh-add' command not found. Please install OpenSSH." >&2
  exit 1
fi

# Check if 'fzf' is available (needed for interactive selection)
if ! command -v fzf >/dev/null 2>&1; then
  echo "Warning: 'fzf' not found. Interactive selection will not be available." >&2
fi

# Handle parameter or interactive selection
if [ $# -eq 0 ]; then
  if ! command -v fzf >/dev/null 2>&1; then
    echo "Error: No key path provided and fzf not available for interactive selection." >&2
    echo "Usage: $0 <key-path>" >&2
    exit 1
  fi

  KEY_PATH="$(list_ssh_keys | fzf --ansi --prompt='Select SSH key: ' --height=40% --reverse || true)"

  if [ -z "${KEY_PATH}" ]; then
    echo "No key selected. Exiting."
    exit 0
  fi
else
  KEY_PATH="$1"
fi

# Resolve the actual file path (handle color codes and extensions)
# First, strip ANSI color codes from the selected path
CLEAN_KEY_PATH=$(echo "$KEY_PATH" | sed -r "s/\x1B\[[0-9;]*[mG]//g")

# Check if the path is already absolute (from symlink resolution)
if [[ "$CLEAN_KEY_PATH" == /* ]]; then
  if [ -f "$CLEAN_KEY_PATH" ]; then
    ACTUAL_FILE="$CLEAN_KEY_PATH"
  elif [ -f "${CLEAN_KEY_PATH}.gpg" ]; then
    ACTUAL_FILE="${CLEAN_KEY_PATH}.gpg"
  else
    echo "Error: Key file not found: ${CLEAN_KEY_PATH}" >&2
    exit 1
  fi
else
  # Relative path - construct from ~/.ssh
  # First check if the file exists as-is
  if [ -f "${HOME}/.ssh/${CLEAN_KEY_PATH}" ]; then
    ACTUAL_FILE="${HOME}/.ssh/${CLEAN_KEY_PATH}"
  # Then check if it's a .gpg file without the extension (display name)
  elif [ -f "${HOME}/.ssh/${CLEAN_KEY_PATH}.gpg" ]; then
    ACTUAL_FILE="${HOME}/.ssh/${CLEAN_KEY_PATH}.gpg"
  else
    echo "Error: Key file not found: ${HOME}/.ssh/${CLEAN_KEY_PATH}" >&2
    exit 1
  fi
fi

key="$ACTUAL_FILE"

if [ ! -f "$key" ]; then
  echo "Error: '$key' not found or not a regular file" >&2
  exit 1
fi

tmp=""
use_shm=false

cleanup() {
  if [[ -n "$tmp" ]] && [[ "$use_shm" == false ]]; then
    rm -f -- "$tmp"
  fi
}
trap cleanup EXIT

# Detect OpenPGP/GPG file
if gpg --list-only --list-packets --quiet -- "$key" > /dev/null 2>&1; then
  base=$(basename "$key")
  base_no_gpg="${base%.gpg}"

  # Determine the temp directory
  if [[ -n "${SSH_RUNTIME_FOLDER:-}" ]] && [[ -L "${HOME}/.ssh/runtime" ]] && [[ "$(readlink "${HOME}/.ssh/runtime")" == "$SSH_RUNTIME_FOLDER" ]]; then
    # Use ~/.ssh/runtime if it is a symlink to SSH_RUNTIME_FOLDER
    tmp_dir="${HOME}/.ssh/runtime"
    use_shm=true
  elif [[ -n "${SSH_RUNTIME_FOLDER:-}" ]] && [[ "$SSH_RUNTIME_FOLDER" == /dev/shm* ]]; then
    # Use SSH_RUNTIME_FOLDER if it starts with /dev/shm
    tmp_dir="$SSH_RUNTIME_FOLDER"
    use_shm=true
  else
    tmp_dir="${TMPDIR:-/tmp}"
    use_shm=false
  fi

  # Respect relative path from ~/.ssh in the temp directory structure
  # Extract the relative path from ~/.ssh
  if [[ "$key" == "${HOME}/.ssh/"* ]]; then
    # Remove ${HOME}/.ssh/ prefix to get relative path
    relative_path="${key#"${HOME}/.ssh/"}"
    # Get the directory part (excluding filename)
    relative_dir=$(dirname "$relative_path")

    if [[ "$relative_dir" != "." ]]; then
      # Create the temp path maintaining the directory structure
      tmp="${tmp_dir}/${relative_dir}/${base_no_gpg}"
      # Create the directory if it doesn't exist
      mkdir -p "$(dirname "$tmp")"
    else
      # File is directly in ~/.ssh
      tmp="${tmp_dir}/${base_no_gpg}"
    fi
  else
    # File is not in ~/.ssh, use simple naming
    tmp="${tmp_dir}/ssh.${base_no_gpg}"
  fi

  if ! gpg --decrypt --quiet --yes --output "$tmp" -- "$key"; then
    echo "Error: GPG decryption failed" >&2
    exit 1
  fi

  chmod 600 -- "$tmp"
  ssh-add -- "$tmp"
else
  ssh-add -- "$key"
fi
